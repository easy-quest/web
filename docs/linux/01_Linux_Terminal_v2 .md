# Linux Terminal ч.1 | Это должен знать каждый продвинутый пользователь Linux



### Что такое терминал в Linux?

Командная строка Linux - это текстовый интерфейс компьютера. Часто его называют  оболочкой, терминалом, консолью, приглашением и пр. По началу он может  показаться сложным и запутанным в использовании, но возможность  копировать и вставлять команды в сочетании с мощностью и гибкостью  позволяют упростить написание и использование инструкций, а также  воспользоваться скрытыми возможностями системы, которые зачастую нельзя  полностью отразить в графическом интерфейсе.

Скриншот окна эмулятора терминала Ubuntu 20.04

Каждая система Linux включает в себя тот или иной эмулятор терминала. Во  многих дистрибутивах Linux его можно запустить с помощью сочетания  клавиш *Ctrl + Alt + T* или через меню приложений. 

> В качестве примера я буду использовать эмулятор терминала Ubuntu 20.04.  

### Краткий ликбез

В годы становления компьютерной индустрии одна из первых операционных  систем называлась Unix. Она была разработана для работы в качестве  многопользовательской системы на мэйнфреймах, при этом пользователи  подключались к ним удаленно через отдельные терминалы. Эти терминалы  были довольно простыми по современным стандартам: лишь клавиатура и  экран, без возможности локального запуска программ. Терминалы просто  отправляли нажатия клавиш на сервер и отображали все полученные данные  на экране. Не было ни мыши, ни красивой графики, все данные отправлялись и принимались исключительно в текстовой форме. 

Фото терминала с дисплеем (слева на переднем плане) и мэйнфрейма (справа, похож на большой шкаф)

По сравнению с графикой, текст требует очень мало ресурсов. Даже на  машинах 1970-х годов, на которых были запущены сотни терминалов с  использованием медленных (по сегодняшним меркам) сетевых соединений ,  пользователи могли взаимодействовать с программами быстро и эффективно.  Для увеличения скорости работы с терминалом команды состояли всего из  нескольких символов. Скорость работы вкупе с эффективностью  делают  текстовый интерфейс популярным и в наши дни.

Сейчас, чтобы создать, переименовать или скопировать файл нам требуется мышь и  графический интерфейс, а пользователи терминалов выполняли эти задачи  при помощи текстовых команд. Для каждой из этих задач требовалась  собственная программа или команда: одна для смены каталогов (*cd*), другая для вывода их содержимого (*ls*), третья для переименования или перемещения файлов (*mv*), и так далее. 

Чтобы координировать выполнение каждой из этих программ, была одна *"главная",* к которой подключался пользователь, чтобы уже её использовать для ввода команд. Эта программа получила название *"оболочка"* (*shell*), так как в каком-то смысле она "обволакивала" запускаемые в ней  программы, позволяя передавать данные сразу из одной в другую,  использовать специальные символы подстановки для работы с большим  количеством файлов, имеющих одинаковое имя и т.д. Пользователи могли  даже написать простой код, называемый сценарием оболочки (*shell script)*, который можно было использовать для автоматизации длинных серий команд с целью упрощения сложных задач. 

Первоначально программу оболочки Unix можно было вызвать с помощью команды *"sh"*, но с годами она расширялась и заменялась, поэтому в современных дистрибутивах Linux оболочка называется *"bash"*. 

Linux - это своего рода потомок Unix. Ядро Linux спроектировано так, чтобы  вести себя аналогично системе Unix, так что большинство старых оболочек и других текстовых программ вполне успешно могут работать и по сей день  на современных дистрибутивах Linux. 

Теоретически можно даже подключить один из тех старых терминалов 1970-х годов к  современному Linux-компьютеру и получить через него доступ к оболочке.  Но в наши дни гораздо чаще используется программный терминал: тот же  старый текстовый интерфейс в стиле Unix, но работающий в оконном режиме  параллельно с другими графическими программами. 

Фрагмент справки по команде "bash"

> Для удобства далее я буду называть эмулятор терминала просто терминалом. 

### Начало работы с терминалом

Для лучшего понимания описываемых далее команд, настоятельно рекомендую Вам запустить терминал на своём ПК и осуществлять ввод команд параллельно с изучением данной статьи. В дистрибутивах Linux он имеет примерно  одинаковый вид:

Терминал в Ubuntu 20.04

После открытия Вас будет ожидать приглашение на ввод команды -  имя_пользователя@имя_компьютера: ~$ и квадратный мигающий курсор (в  некоторых терминалах - мигающий знак подчёркивания). Это указывает на  то, что в данный момент не выполняется каких-либо задач и компьютер  готов к вводу. 

> Знак тильды (~) означает, что в данный момент работа ведётся в папке  текущего пользователя системы (в основном это важно при работе с  файлами). 
> $ говорит нам о том, что все команды выполняются от имени обычного пользователя.

Давайте введём первую команду: *'pwd' (используйте только строчные буквы, после ввода команды не забудьте нажать Enter).*

> В отличие от Windows, терминал Linux чувствителен к регистру

Результат выполнения команды "pwd"

Обратите внимание, что ввод команды осуществляется на той же строке, что и  приглашение, а результат выводится ниже этой строки. Затем следует новое приглашение на ввод команды.

Сама команда *pwd* - это аббревиатура от "**p**rint **w**orking **d**irectory" (печать рабочего каталога). При работе с файлами она может помочь  убедиться, что вы собираетесь выполнить команду в нужном каталоге, чтобы избежать многих проблем.

> У некоторых команд вывод может занимать не одну строку, а намного больше. Также бывают случаи, когда после ввода команды сразу следует  приглашение на ввод следующей - это значит, что предыдущая команда была  выполнена успешно.  Вспомните про медленные сетевые соединения,  описанные выше; не возвращая результат удавалось сэкономить несколько  драгоценных байтов. Кое-какие команды до сих пор следуют этой традиции.

Можно сменить рабочий каталог, используя команду *'cd'* (аббревиатура от **c**hange **d**irectory - сменить каталог). Введём, например, 'cd /' и узнаем путь к текущему каталогу:

После изменения рабочий каталог находится в корневой директории (root).

> '/' (forward slash, слэш, косая черта) - это разделитель каталогов. Не  путайте с разделителем каталогов в Windows, там используется '\'  (backslash, бэкслеш, обратный слэш, обратная косая черта),  унаследованный от DOS.

Теперь наш рабочий каталог - *'/'*. Если Вы работали с Windows, то, вероятно, привыкли к тому, что каждый  диск имеет свою собственную букву, а основной диск обычно “C:”.  Unix-подобные системы вместо такого разделения используют единую  файловую систему, позволяющую подключить (смонтировать) отдельные диски в любое подходящее место файловой системы. Каталог *'/'*, часто называемый корневым каталогом *(root)*, является основой этой единой файловой системы. Оттуда все остальное разветвляется, образуя дерево каталогов и подкаталогов.

> Слово root также может иметь другое значение: root-это также имя учётной  записи суперпользователя, используемое с первых дней Unix.  Суперпользователь, как следует из названия, обладает большими  полномочиями, чем обычный пользователь, поэтому может легко нанести  ущерб системе при неправильном использовании команд. 

По умолчанию папки пользователя хранятся в /home. Чтобы перейти в этот каталог, достаточно использовать команду *'cd home':*

Переход в каталог '/home'

Для возвращения на один каталог назад используется команда cd и две точки: *'cd ..'*

Возврат "назад" на одну директорию 

> Обратите внимание, что 'cd' и '..' разделены пробелом.

> Если требуется вернуться более чем на один каталог, можно использовать '..'  несколько раз. Например, команда для возврата на два каталога будет  выглядеть следующим образом: 'cd ../..'



Использование команды *'cd'* без аргументов позволит нам быстро вернуться в каталог текущего пользователя из любой точки файловой системы:

Быстрый возврат в каталог текущего пользователя

Теперь, если мы снова захотим перейти в корневой каталог не используя команду *'cd /',* то можем просто переместиться сразу на два каталога назад, используя команду '*cd ../..':*

Результат выполнения 'cd ../..'

> Также можно сразу после возврата в нужный каталог перейти в соответствующий  подкаталог при помощи ввода всего одной команды, например: 'cd  ../../etc'. В этом случае сначала мы из папки пользователя перемещаемся в корневой каталог, а из него сразу же перемещаемся в подкаталог 'etc'

### Относительные и абсолютные пути

В большинстве примеров, рассмотренных выше, использовались **относительные** пути, зависящие от нашего текущего рабочего каталога. Разберём это на вышеописанном примере: чтобы попасть в каталог *'etc'*, мы сначала перемещались на два каталога назад, а уже затем переходили в нужный каталог, то есть наш путь начинался в каталоге текущего пользователя. 

> Если мы, находясь в папке пользователя, попытаемся выполнить 'cd etc', то  получим ошибку, так как программа будет искать подкаталог 'etc' в  текущем рабочем каталоге:

Ошибка при использовании относительного пути

При работе с гораздо большим количеством каталогов использование  относительных путей будет крайне отрицательно влиять на эффективность  работы с терминалом, поэтому там, где это удобно, используют **абсолютные** пути. Мы уже рассматривали две команды, использующие этот тип пути: *'cd'* и *'cd /'.* В первом случае мы сразу попадали в каталог пользователя, а во втором - в корень файловой системы, минуя длинную цепочку возвратов и переходов.

> Наличие косой черты перед путём перехода говорит программе, что используется  абсолютный путь, берущий своё начало из корневого каталога.

Зная это, становится гораздо проще перейти в каталог *'etc'* из каталога пользователя:

Переход в 'etc', с использованием абсолютного пути

Попробуем перейти в каталог рабочего стола текущего пользователя аналогичным образом:

Почему путь указан в кавычках?

> Если Вы забыли имя текущего пользователя, воспользуйтесь командой 'whoami'.

> Программа cd ожидает, что пользователь укажет только один путь, поэтому в случае, когда попадается каталог или файл, в названии которого присутствует  пробел, она "думает", что пользователь ошибся и указал несколько путей,  разделенных пробелом. Чтобы программа поняла, что этот пробел относится к имени каталога или файла, необходимо указывать его в кавычках (или  брать в кавычки весь путь)

Я уже говорил, что в строке приглашения после двоеточия указывается путь к текущему рабочему каталогу, но почему после ввода последней команды  этот путь оказался таким коротким? Также я обращал Ваше внимание, что *'~'* обозначает домашний каталог текущего пользователя, из чего можно сделать вывод, что вместо длинной команды 
*' cd /home/USERNAME/Загрузки'* можно использовать более короткую и простую *'cd ~/Загрузки':*

Простой переход в каталог "Загрузки" с использованием абсолютного пути

> Чтобы потренироваться в переходах между каталогами, можете расположить на  экране рядом два окна, в одном из которых будет открыт терминал, а в  другом - файловый менеджер. Перейдите сначала в какой-нибудь каталог,  используя файловый менеджер, а затем попробуйте проделать то же самое с  использованием терминала

Чтобы не делать статью слишком громоздкой, я разбил материал на несколько  частей. В следующей статье рассмотрим примеры создания и работы с  файлами и каталогами, познакомимся с *man*'ом и попробуем выполнить несколько команд от имени суперпользователя. 

> Если статья была полезной - ставьте лайк и подписывайтесь на канал, чтобы не пропустить продожение. Если что-то непонятно или хотелось бы дополнить - оставляйте комментарий, с удовольствием отвечу :)



**UPD** от 25.05.2021: [[02_Linux_Terminal | Ссылка на вторую часть]]