[zen.yandex.ru](https://zen.yandex.ru/media/it_doc/linux-terminal-ch1--eto-doljen-znat-kajdyi-prodvinutyi-polzovatel-linux-60a267178bcfa40dc36c1a55)

# Linux Terminal ч.1 | Это должен знать каждый продвинутый пользователь Linux

11-15 минут

------

### Что такое терминал в Linux?

Командная строка Linux - это текстовый интерфейс компьютера. Часто его называют  оболочкой, терминалом, консолью, приглашением и пр. По началу он может  показаться сложным и запутанным в использовании, но возможность  копировать и вставлять команды в сочетании с мощностью и гибкостью  позволяют упростить написание и использование инструкций, а также  воспользоваться скрытыми возможностями системы, которые зачастую нельзя  полностью отразить в графическом интерфейсе.

Каждая система Linux включает в себя тот или иной эмулятор  терминала. Во многих дистрибутивах Linux его можно запустить с помощью  сочетания клавиш *Ctrl + Alt + T* или через меню приложений. 

> В качестве примера я буду использовать эмулятор терминала Ubuntu 20.04.  

### Краткий ликбез

В годы становления компьютерной индустрии одна из первых операционных  систем называлась Unix. Она была разработана для работы в качестве  многопользовательской системы на мэйнфреймах, при этом пользователи  подключались к ним удаленно через отдельные терминалы. Эти терминалы  были довольно простыми по современным стандартам: лишь клавиатура и  экран, без возможности локального запуска программ. Терминалы просто  отправляли нажатия клавиш на сервер и отображали все полученные данные  на экране. Не было ни мыши, ни красивой графики, все данные отправлялись и принимались исключительно в текстовой форме. 

По сравнению с графикой, текст требует очень мало ресурсов.  Даже на машинах 1970-х годов, на которых были запущены сотни терминалов с использованием медленных (по сегодняшним меркам) сетевых соединений ,  пользователи могли взаимодействовать с программами быстро и эффективно.  Для увеличения скорости работы с терминалом команды состояли всего из  нескольких символов. Скорость работы вкупе с эффективностью  делают  текстовый интерфейс популярным и в наши дни.

Сейчас,  чтобы создать, переименовать или скопировать файл нам требуется мышь и  графический интерфейс, а пользователи терминалов выполняли эти задачи  при помощи текстовых команд. Для каждой из этих задач требовалась  собственная программа или команда: одна для смены каталогов (*cd*), другая для вывода их содержимого (*ls*), третья для переименования или перемещения файлов (*mv*), и так далее. 

Чтобы координировать выполнение каждой из этих программ, была одна *"главная",* к которой подключался пользователь, чтобы уже её использовать для ввода команд. Эта программа получила название *"оболочка"* (*shell*), так как в каком-то смысле она "обволакивала" запускаемые в ней  программы, позволяя передавать данные сразу из одной в другую,  использовать специальные символы подстановки для работы с большим  количеством файлов, имеющих одинаковое имя и т.д. Пользователи могли  даже написать простой код, называемый сценарием оболочки (*shell script)*, который можно было использовать для автоматизации длинных серий команд с целью упрощения сложных задач. 

Первоначально программу оболочки Unix можно было вызвать с помощью команды *"sh"*, но с годами она расширялась и заменялась, поэтому в современных дистрибутивах Linux оболочка называется *"bash"*. 

Linux - это своего рода потомок Unix. Ядро Linux спроектировано так, чтобы  вести себя аналогично системе Unix, так что большинство старых оболочек и других текстовых программ вполне успешно могут работать и по сей день  на современных дистрибутивах Linux. 

Теоретически  можно даже подключить один из тех старых терминалов 1970-х годов к  современному Linux-компьютеру и получить через него доступ к оболочке.  Но в наши дни гораздо чаще используется программный терминал: тот же  старый текстовый интерфейс в стиле Unix, но работающий в оконном режиме  параллельно с другими графическими программами. 

![Фрагмент справки по команде "bash"](https://avatars.mds.yandex.net/get-zen_doc/1590219/pub_60a267178bcfa40dc36c1a55_60a514acddb76a10236ffef3/scale_1200)Фрагмент справки по команде "bash"

Фрагмент справки по команде "bash"

> Для удобства далее я буду называть эмулятор терминала просто терминалом. 

### Начало работы с терминалом

Для лучшего понимания описываемых далее команд, настоятельно рекомендую Вам запустить терминал на своём ПК и осуществлять ввод команд параллельно с изучением данной статьи. В дистрибутивах Linux он имеет примерно  одинаковый вид:

![Терминал в Ubuntu 20.04](https://avatars.mds.yandex.net/get-zen_doc/3938527/pub_60a267178bcfa40dc36c1a55_60a5165fa28a8d164828279d/scale_1200)Терминал в Ubuntu 20.04

Терминал в Ubuntu 20.04

После открытия Вас будет ожидать приглашение на ввод команды -  имя_пользователя@имя_компьютера: ~$ и квадратный мигающий курсор (в  некоторых терминалах - мигающий знак подчёркивания). Это указывает на  то, что в данный момент не выполняется каких-либо задач и компьютер  готов к вводу. 

> Знак тильды (~) означает,  что в данный момент работа ведётся в папке текущего пользователя системы (в основном это важно при работе с файлами). 
> $ говорит нам о том, что все команды выполняются от имени обычного пользователя.

Давайте введём первую команду: *'pwd' (используйте только строчные буквы, после ввода команды не забудьте нажать Enter).*

> В отличие от Windows, терминал Linux чувствителен к регистру

![Результат выполнения команды "pwd"](https://avatars.mds.yandex.net/get-zen_doc/3950646/pub_60a267178bcfa40dc36c1a55_60a519e92125b233e9bc3468/scale_1200)Результат выполнения команды "pwd"

Обратите внимание, что ввод команды осуществляется на той же строке, что и  приглашение, а результат выводится ниже этой строки. Затем следует новое приглашение на ввод команды.

Сама команда *pwd* - это аббревиатура от "**p**rint **w**orking **d**irectory" (печать рабочего каталога). При работе с файлами она может помочь  убедиться, что вы собираетесь выполнить команду в нужном каталоге, чтобы избежать многих проблем.

> У некоторых команд вывод может занимать не одну строку, а намного больше. Также бывают  случаи, когда после ввода команды сразу следует приглашение на ввод  следующей - это значит, что предыдущая команда была выполнена успешно.   Вспомните про медленные сетевые соединения, описанные выше; не возвращая результат удавалось сэкономить несколько драгоценных байтов. Кое-какие  команды до сих пор следуют этой традиции.

Можно сменить рабочий каталог, используя команду *'cd'* (аббревиатура от **c**hange **d**irectory - сменить каталог). Введём, например, 'cd /' и узнаем путь к текущему каталогу:

![После изменения рабочий каталог находится в корневой директории (root).](https://avatars.mds.yandex.net/get-zen_doc/3965361/pub_60a267178bcfa40dc36c1a55_60a7940b1b112a2f547e997f/scale_1200)После изменения рабочий каталог находится в корневой директории (root).

После изменения рабочий каталог находится в корневой директории (root).

> '/' (forward slash, слэш, косая черта) - это разделитель каталогов. Не  путайте с разделителем каталогов в Windows, там используется '\'  (backslash, бэкслеш, обратный слэш, обратная косая черта),  унаследованный от DOS.

Теперь наш рабочий каталог - *'/'*. Если Вы работали с Windows, то, вероятно, привыкли к тому, что каждый  диск имеет свою собственную букву, а основной диск обычно “C:”.  Unix-подобные системы вместо такого разделения используют единую  файловую систему, позволяющую подключить (смонтировать) отдельные диски в любое подходящее место файловой системы. Каталог *'/'*, часто называемый корневым каталогом *(root)*, является основой этой единой файловой системы. Оттуда все остальное разветвляется, образуя дерево каталогов и подкаталогов.

> Слово root также может иметь другое значение: root-это также имя учётной  записи суперпользователя, используемое с первых дней Unix.  Суперпользователь, как следует из названия, обладает большими  полномочиями, чем обычный пользователь, поэтому может легко нанести  ущерб системе при неправильном использовании команд. 

По умолчанию папки пользователя хранятся в /home. Чтобы перейти в этот каталог, достаточно использовать команду *'cd home':*

![Переход в каталог '/home'](https://avatars.mds.yandex.net/get-zen_doc/3842094/pub_60a267178bcfa40dc36c1a55_60a798fe57455d23ca267a56/scale_1200)Переход в каталог '/home'

Переход в каталог '/home'

Для возвращения на один каталог назад используется команда cd и две точки: *'cd ..'*

![Возврат "назад" на одну директорию ](https://avatars.mds.yandex.net/get-zen_doc/4414226/pub_60a267178bcfa40dc36c1a55_60a799ccce8b30007884615c/scale_1200)Возврат "назад" на одну директорию 

Возврат "назад" на одну директорию 

> Обратите внимание, что 'cd' и '..' разделены пробелом.

> Если требуется вернуться более чем на один каталог, можно использовать '..'  несколько раз. Например, команда для возврата на два каталога будет  выглядеть следующим образом: 'cd ../..'

Использование команды *'cd'* без аргументов позволит нам быстро вернуться в каталог текущего пользователя из любой точки файловой системы:

![Быстрый возврат в каталог текущего пользователя](https://avatars.mds.yandex.net/get-zen_doc/4414226/pub_60a267178bcfa40dc36c1a55_60a79b1970bb2023e796ea5b/scale_1200)Быстрый возврат в каталог текущего пользователя

Быстрый возврат в каталог текущего пользователя

Теперь, если мы снова захотим перейти в корневой каталог не используя команду *'cd /',* то можем просто переместиться сразу на два каталога назад, используя команду '*cd ../..':*

![Результат выполнения 'cd ../..'](https://avatars.mds.yandex.net/get-zen_doc/4790423/pub_60a267178bcfa40dc36c1a55_60a79d3d2a445c5fd0848219/scale_1200)Результат выполнения 'cd ../..'

Результат выполнения 'cd ../..'

> Также можно сразу после возврата в нужный каталог перейти в соответствующий  подкаталог при помощи ввода всего одной команды, например: 'cd  ../../etc'. В этом случае сначала мы из папки пользователя перемещаемся в корневой каталог, а из него сразу же перемещаемся в подкаталог 'etc'

### Относительные и абсолютные пути

В большинстве примеров, рассмотренных выше, использовались **относительные** пути, зависящие от нашего текущего рабочего каталога. Разберём это на вышеописанном примере: чтобы попасть в каталог *'etc'*, мы сначала перемещались на два каталога назад, а уже затем переходили в нужный каталог, то есть наш путь начинался в каталоге текущего пользователя. 

> Если мы, находясь в папке пользователя, попытаемся выполнить 'cd etc', то  получим ошибку, так как программа будет искать подкаталог 'etc' в  текущем рабочем каталоге:

![Ошибка при использовании относительного пути](https://avatars.mds.yandex.net/get-zen_doc/4478350/pub_60a267178bcfa40dc36c1a55_60ab7b4bf1146d0d08410b54/scale_1200)Ошибка при использовании относительного пути

Ошибка при использовании относительного пути

При работе с гораздо большим количеством каталогов использование  относительных путей будет крайне отрицательно влиять на эффективность  работы с терминалом, поэтому там, где это удобно, используют **абсолютные** пути. Мы уже рассматривали две команды, использующие этот тип пути: *'cd'* и *'cd /'.* В первом случае мы сразу попадали в каталог пользователя, а во втором - в корень файловой системы, минуя длинную цепочку возвратов и переходов.

> Наличие косой черты перед путём перехода говорит программе, что используется  абсолютный путь, берущий своё начало из корневого каталога.

Зная это, становится гораздо проще перейти в каталог *'etc'* из каталога пользователя:

![Переход в 'etc', с использованием абсолютного пути](https://avatars.mds.yandex.net/get-zen_doc/2957013/pub_60a267178bcfa40dc36c1a55_60ab7e36e4677d6f7cbb36f4/scale_1200)Переход в 'etc', с использованием абсолютного пути

Переход в 'etc', с использованием абсолютного пути

Попробуем перейти в каталог рабочего стола текущего пользователя аналогичным образом:

![Почему путь указан в кавычках?](https://avatars.mds.yandex.net/get-zen_doc/4079337/pub_60a267178bcfa40dc36c1a55_60ab7f83d750f6113a07c66e/scale_1200)Почему путь указан в кавычках?

Почему путь указан в кавычках?

> Если Вы забыли имя текущего пользователя, воспользуйтесь командой 'whoami'.

> Программа cd ожидает, что пользователь укажет только один путь, поэтому в случае, когда попадается каталог или файл, в названии которого присутствует  пробел, она "думает", что пользователь ошибся и указал несколько путей,  разделенных пробелом. Чтобы программа поняла, что этот пробел относится к имени каталога или файла, необходимо указывать его в кавычках (или  брать в кавычки весь путь)

![img](https://avatars.mds.yandex.net/get-zen_doc/4079337/pub_60a267178bcfa40dc36c1a55_60ab820eb9ff4e00ded94d55/scale_1200)

Я уже говорил, что в строке приглашения после двоеточия указывается путь к текущему рабочему каталогу, но почему после ввода последней команды  этот путь оказался таким коротким? Также я обращал Ваше внимание, что *'~'* обозначает домашний каталог текущего пользователя, из чего можно сделать вывод, что вместо длинной команды 
*' cd /home/USERNAME/Загрузки'* можно использовать более короткую и простую *'cd ~/Загрузки':*

![Простой переход в каталог "Загрузки" с использованием абсолютного пути](https://avatars.mds.yandex.net/get-zen_doc/2355127/pub_60a267178bcfa40dc36c1a55_60ab84e6b9ff4e00dee3e1d2/scale_1200)Простой переход в каталог "Загрузки" с использованием абсолютного пути

Простой переход в каталог "Загрузки" с использованием абсолютного пути

> Чтобы потренироваться в переходах между каталогами, можете расположить на  экране рядом два окна, в одном из которых будет открыт терминал, а в  другом - файловый менеджер. Перейдите сначала в какой-нибудь каталог,  используя файловый менеджер, а затем попробуйте проделать то же самое с  использованием терминала

Чтобы не делать  статью слишком громоздкой, я разбил материал на несколько частей. В  следующей статье рассмотрим примеры создания и работы с файлами и  каталогами, познакомимся с *man*'ом и попробуем выполнить несколько команд от имени суперпользователя. 

> Если статья была полезной - ставьте лайк и подписывайтесь на канал, чтобы не пропустить продожение. Если что-то непонятно или хотелось бы дополнить - оставляйте комментарий, с удовольствием отвечу :)

**UPD** от 25.05.2021: [Ссылка на вторую часть:](obsidian://open?vault=newuser&file=PycharmProjects%2Fweb%2Fdocs%2Flinux%2F02_Linux_Terminal%20)