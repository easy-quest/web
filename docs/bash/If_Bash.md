---
created: 2021-10-11T23:38:44 (UTC +00:00)
source: https://ryanstutorials.net/bash-scripting-tutorial/bash-if-statements.php
author: Ivan Yastrebov
---

# Операторы If - Учебное пособие по созданию сценариев в Bash

---


## Вступление

Операторы Bash if очень полезны. В этом разделе нашего руководства по созданию сценариев Bash вы узнаете, как можно использовать операторы if в сценариях Bash для автоматизации задач.

Операторы **if** (и, тесно связанные, операторы **case** ) позволяют нам принимать решения в наших сценариях Bash. Они позволяют нам решать, запускать или нет фрагмент кода на основе условий, которые мы можем установить. Операторы if в сочетании с [циклами](https://ryanstutorials.net/bash-scripting-tutorial/bash-loops.php) (которые мы рассмотрим в следующем разделе) позволяют нам создавать гораздо более сложные сценарии, которые могут решать более крупные задачи.

Подобно тому, что мы рассматривали в предыдущих разделах, их синтаксис очень специфичен, поэтому будьте в курсе всех мелких деталей.

## Основные операторы If

Базовый оператор if фактически говорит, что **если** конкретный тест верен, выполните заданный набор действий. Если это неправда, не выполняйте эти действия. Если соответствует приведенному ниже формату:

```bash
if [ <some test> ]
then
<commands>
fi
```

Все, что находится между **then** и **fi** (в обратном направлении), будет выполнено, только если проверка (в квадратных скобках) верна.

Давайте посмотрим на простой пример:


```bash
#if_example.sh	
#!/bin/bash
if [ $1 -gt 100 ]
then
	echo Эй, это большое число.
	pwd
fi
data
```

Давайте разберемся:

-   **Строка 4** - Посмотрим, больше ли первый аргумент командной строки 100
-   **Строки 6 и 7** - будут запущены только в том случае, если тест в строке 4 вернет истину. Здесь вы можете иметь столько команд, сколько захотите.
-   **Строка 6** - обратная косая черта (\\) перед одинарной кавычкой (') необходима, поскольку одинарная кавычка имеет особое значение для bash, и мы не хотим этого особого значения. Обратная косая черта ускользает от специального значения, чтобы снова сделать обычную одинарную кавычку.
-   **Строка 8** - fi сигнализирует об окончании оператора if. Все команды после этого будут выполняться в обычном режиме.
-   **Строка 10** - поскольку эта команда находится за пределами оператора if, она будет запущена независимо от результата оператора if.

1.  ./if\_example.sh 15
2.  Пн 11 окт 18:29:01 2021
3.  ./if\_example.sh 150
4.  Эй, это большое количество.
5.  / home / ryan / bin
6.  Пн 11 окт 18:29:01 2021

Всегда полезно тестировать свои сценарии с вводом, который охватывает различные возможные сценарии.

## Тестовое задание

Квадратные скобки (\[\]) в приведенном выше операторе **if** на самом деле являются ссылкой на команду **test** . Это означает, что здесь также могут использоваться все операторы, которые позволяет тест. Посмотрите справочную страницу для теста, чтобы увидеть все возможные операторы (их довольно много), но некоторые из наиболее распространенных из них перечислены ниже.

Оператор

Описание

! ВЫРАЖЕНИЕ

ВЫРАЖЕНИЕ ложное.

\-n СТРОКА

Длина STRING больше нуля.

\-z СТРОКА

Длина строки STRING равна нулю (т. Е. Она пуста).

STRING1 = STRING2

STRING1 совпадает с STRING2

STRING1! = STRING2

STRING1 не равно STRING2

ЦЕЛОЕ1-экв ЦЕЛОЕ2

INTEGER1 численно равен INTEGER2

ЦЕЛОЕ1 -gt ЦЕЛОЕ2

INTEGER1 численно больше INTEGER2

ЦЕЛОЕ1 -lt ЦЕЛОЕ2

INTEGER1 численно меньше INTEGER2

\-d ФАЙЛ

ФАЙЛ существует и является каталогом.

\-e ФАЙЛ

Файл существует.

\-r ФАЙЛ

ФАЙЛ существует, и разрешение на чтение предоставлено.

\-s FILE

ФАЙЛ существует, и его размер больше нуля (т. Е. Он не пустой).

\-w ФАЙЛ

ФАЙЛ существует, и разрешение на запись предоставлено.

\-x ФАЙЛ

ФАЙЛ существует, и предоставлено разрешение на выполнение.

Несколько замечаний:

-   **\=** немного отличается от **\-eq** . \[001 = 1\] вернет false, так как = выполняет сравнение строк (т. Е. Символ для символа одинаков), тогда как -eq выполняет числовое сравнение, означающее, что \[001 -eq 1\] вернет true.
-   Когда мы говорим о ФАЙЛЕ выше, мы на самом деле имеем в виду [путь](https://ryanstutorials.net/linuxtutorial/navigation.php) . Помните, что путь может быть абсолютным или относительным и может относиться к файлу или каталогу.
-   Поскольку \[\] - это просто ссылка на команду **test,** мы можем экспериментировать и устранять неполадки с помощью test в командной строке, чтобы убедиться, что мы правильно понимаем ее поведение.

1.  тест 001 = 1
2.  эхо $?
3.  1
4.  тест 001-экв 1
5.  эхо $?
6.  0
7.  прикоснуться к моему файлу
8.  test -s myfile
9.  эхо $?
10.  1
11.  ls / etc> myfile
12.  test -s myfile
13.  эхо $?
14.  0

Давайте разберемся:

-   **Строка 1** - выполнить сравнение на основе строки. Тест не печатает результат, поэтому вместо этого мы проверяем его статус выхода, что мы и сделаем в следующей строке.
-   **Строка 2** - переменная **$?** содержит статус выхода ранее запущенной команды (в данном случае test). 0 означает ИСТИНА (или успех). 1 = ЛОЖЬ (или сбой).
-   **Строка 4** - На этот раз мы проводим численное сравнение.
-   **Строка 7** - Создайте новый пустой файл **myfile** (предполагается, что myfile еще не существует).
-   **Строка 8** - Размер **myfile** больше нуля?
-   **Строка 11** - [Перенаправить](https://ryanstutorials.net/linuxtutorial/piping.php) некоторый контент в мой файл, чтобы его размер был больше нуля.
-   **Строка 12** - снова **проверьте** размер **myfile** . На этот раз это ИСТИНА.

## Отступ

Вы заметите, что в приведенном выше операторе **if** мы выделили команды, которые выполнялись, если оператор был истинным. Это называется отступом и является важной частью написания хорошего, чистого кода (на любом языке, а не только в сценариях Bash). Цель состоит в том, чтобы улучшить читаемость и усложнить нам совершение простых глупых ошибок. В Bash нет никаких правил относительно отступов, поэтому вы можете делать отступы или не делать отступы, как вам нравится, и ваши скрипты будут работать точно так же. Однако я настоятельно рекомендую вам сделать отступ в коде (особенно по мере того, как ваши скрипты становятся больше), иначе вам будет все труднее увидеть структуру в ваших скриптах.

## Вложенные операторы If

Кстати об отступах. Вот прекрасный пример того, когда это облегчает вам жизнь. У вас может быть столько операторов **if,** сколько необходимо внутри вашего скрипта. Также возможно иметь оператор if внутри другого оператора if. Например, мы можем захотеть проанализировать число, указанное в командной строке, следующим образом:

#### nested\_if.sh

1.  #! / bin / bash

4.  если \[$ 1-gt 100\]
5.  тогда
6.  echo Эй, это большое число.

8.  если (($ 1% 2 == 0))
9.  тогда
10.  эхо А также является четным числом.
11.  быть
12.  быть

Давайте разберемся:

-   **Строка 4** - Выполните следующее, только если первый аргумент командной строки больше 100.
-   **Строка 8** - это легкая вариация оператора **if** . Если мы хотим проверить выражение, мы можем использовать двойные скобки, как мы это делали для [переменных](https://ryanstutorials.net/bash-scripting-tutorial/bash-variables.php) .
-   **Строка 10** - запускается, только если оба оператора if верны.

Йо, чувак, я хочу, **чтобы** вам нравились операторы **if,** поэтому я помещаю оператор **if** в ваш оператор **if** .

**Xzibit**

(На самом деле [Xzibit](http://knowyourmeme.com/memes/xzibit-yo-dawg) этого не говорил, но я уверен, что он бы сказал, если бы он размещал сценарий Pimp My Bash.)

Вы можете вложить столько операторов if, сколько захотите, но как правило, если вам нужно вложить более трех уровней в глубину, вам, вероятно, следует подумать о реорганизации своей логики.

## Если еще

Иногда мы хотим выполнить определенный набор действий, если утверждение верно, и другой набор действий, если оно неверно. Мы можем приспособиться к этому с помощью механизма **else** .

если \[<какой-то тест>\],  
то  
<команды>  
еще  
<другие команды>  
fi

Теперь мы можем легко читать из файла, если он указан в качестве аргумента командной строки, **иначе -** из STDIN.

#### else.sh

1.  #! / bin / bash

4.  если \[$ # -eq 1\]
5.  тогда
6.  ru $ 1
7.  еще
8.  nl / dev / stdin
9.  быть

## Если Элиф еще

Иногда у нас может быть ряд условий, которые могут привести к разным путям.

если \[<какой-то тест>\],  
то  
<commands>  
elif \[<some test>\]  
затем  
<разные команды>  
еще  
<другие команды>  
fi

Например, может случиться так, что если вам 18 лет или больше, вы можете пойти на вечеринку. Если нет, но у вас есть письмо от родителей, вы можете уйти, но должны вернуться до полуночи. Иначе ты не сможешь уйти.

#### if\_elif.sh

1.  #! / bin / bash

4.  если \[$ 1 -ge 18\]
5.  тогда
6.  эхо Вы можете пойти на вечеринку.
7.  elif \[$ 2 == 'да'\]
8.  тогда
9.  echo Вы можете пойти на вечеринку, но вернитесь до полуночи.
10.  еще
11.  echo Тебе нельзя идти на вечеринку.
12.  быть

Вы можете иметь столько веток elif, сколько захотите. Финальный вариант else также необязателен.

## Логические операции

Иногда мы хотим что-то сделать, только если выполняются несколько условий. В других случаях мы хотели бы выполнить действие, если выполняется одно из нескольких условий. Мы можем учесть это с помощью **логических операторов** .

-   **и** - &&
-   **или** - ||

Например, возможно, мы хотим выполнить операцию только в том случае, если файл доступен для чтения **и** имеет размер больше нуля.

#### and.sh

1.  #! / bin / bash

4.  если \[-r $ 1\] && \[-s $ 1\]
5.  тогда
6.  echo Этот файл полезен.
7.  быть

Возможно, мы хотели бы сделать что-то немного другое, если пользователь будет либо Бобом, либо Энди.

#### or.sh

1.  #! / bin / bash

4.  если \[$ USER == 'bob'\] || \[$ USER == 'andy'\]
5.  тогда
6.  ls -alh
7.  еще
8.  ls
9.  быть

## Заявления по делу

Иногда мы можем захотеть пойти разными путями, основываясь на переменной, соответствующей серии шаблонов. Мы могли бы использовать серию операторов **if** и **elif,** но вскоре это стало невыносимо. К счастью, есть оператор **case,** который может сделать вещи чище. Это немного сложно объяснить, поэтому вот несколько примеров для иллюстрации:

case <переменная> в  
<шаблоне 1>)  
<команды>  
;;  
<образец 2>)  
<другие команды>  
;;  
esac

Вот простой пример:

#### case.sh

1.  #! / bin / bash

4.  футляр $ 1 в
5.  Начните)
6.  запуск эха
7.  ;;
8.  останавливаться)
9.  эхо-остановка
10.  ;;
11.  рестарт)
12.  перезапуск эха
13.  ;;
14.  \*)
15.  эхо незнаю
16.  ;;
17.  esac

Давайте разберемся:

-   **Строка 4** - с этой строки начинается механизм **корпуса** .
-   **Строка 5** - Если $ 1 равен start, выполните следующие действия. символ) означает конец шаблона.
-   **Строка 7** - мы обозначаем конец этого набора операторов двойной точкой с запятой (;;). Далее следует рассмотреть следующий случай.
-   **Строка 14** - Помните, что тест для каждого случая - это шаблон. **\*** Представляет собой любое количество любых символов. Это существенный улов, если ни один из других случаев не совпадает. Это не обязательно, но часто используется.
-   **Строка 17** - esac - обратный регистр и указывает, что мы находимся в конце оператора case. Любые другие операторы после этого будут выполняться как обычно.

1.  ./case.sh start
2.  начало
3.  ./case.sh перезапуск
4.  перезапуск
5.  ./case.sh бла
6.  не знаю

Теперь давайте рассмотрим чуть более сложный пример, в котором шаблоны используются немного чаще.

#### disk\_useage.sh

1.  #! / bin / bash

4.  space\_free = $ (df -h | awk '{print $ 5}' | sort -n | tail -n 1 | sed 's /% //')

6.  case $ space\_free в
7.  \[1-5\]\*)
8.  echo Доступно много места на диске
9.  ;;
10.  \[6-7\]\*)
11.  echo В ближайшем будущем может возникнуть проблема
12.  ;;
13.  8\*)
14.  echo Может быть, нам стоит очистить старые файлы
15.  ;;
16.  9\*)
17.  эхо Скоро у нас может возникнуть серьезная проблема
18.  ;;
19.  \*)
20.  эхо Что-то здесь не так
21.  ;;
22.  esac

## Резюме

если

Выполните набор команд, если проверка верна.

еще

Если тест не соответствует действительности, выполните другой набор команд.

Элиф

Если предыдущий тест вернул false, попробуйте этот.

&&

Выполните операцию и.

||

Выполните операцию или.

кейс

Выберите набор команд для выполнения в зависимости от строки, соответствующей определенному шаблону.

Отступ

Отступы упрощают чтение кода. Это становится все более важным по мере того, как ваши сценарии Bash становятся длиннее.

Планирование

Теперь, когда ваши скрипты становятся немного более сложными, вы, вероятно, захотите потратить немного времени на размышления о том, как вы их структурируете, прежде чем погрузиться в них.

## мероприятия

Теперь давайте примем решения.

-   Создайте сценарий Bash, который будет принимать 2 числа в качестве аргументов командной строки. На экране будет выведено большее из двух чисел.
-   Создайте сценарий Bash, который будет принимать файл в качестве аргумента командной строки и анализировать его определенным образом. например. вы можете проверить, является ли файл исполняемым или доступным для записи. Вы должны вывести одно сообщение, если оно истинно, и другое, если оно ложно.
-   Создайте сценарий Bash, который будет печатать сообщение в зависимости от того, какой сегодня день недели (например, «Happy hump day» для Wedensday, «TGIF» для пятницы и т. Д.).

###### tags: [scripting tutorial,bash tutorial,bash scripting tutorial,bash,scripting,if,elif,else,if statements,case]  EASYQUEST